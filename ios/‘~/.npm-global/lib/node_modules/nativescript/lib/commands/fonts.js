"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FontsCommand = void 0;
const yok_1 = require("../common/yok");
const constants = require("../constants");
const fontFinder = require("font-finder");
const helpers_1 = require("../common/helpers");
const path = require("path");
class FontsCommand {
    constructor($projectData, $fs, $logger, $projectConfigService) {
        this.$projectData = $projectData;
        this.$fs = $fs;
        this.$logger = $logger;
        this.$projectConfigService = $projectConfigService;
        this.allowedParameters = [];
        this.$projectData.initializeProjectData();
    }
    execute(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const supportedExtensions = [".ttf", ".otf"];
            const defaultFontsFolderPaths = [
                path.join((_a = this.$projectConfigService.getValue("appPath")) !== null && _a !== void 0 ? _a : "", constants.FONTS_DIR),
                path.join(constants.APP_FOLDER_NAME, constants.FONTS_DIR),
                path.join(constants.SRC_DIR, constants.FONTS_DIR),
            ].map((entry) => path.resolve(this.$projectData.projectDir, entry));
            const fontsFolderPath = defaultFontsFolderPaths.find((entry) => this.$fs.exists(entry));
            if (!fontsFolderPath) {
                this.$logger.warn("No fonts folder found.");
                return;
            }
            const files = this.$fs
                .readDirectory(fontsFolderPath)
                .map((entry) => path.parse(entry))
                .filter((entry) => {
                return supportedExtensions.includes(entry.ext);
            });
            if (!files.length) {
                this.$logger.warn("No custom fonts found.");
                return;
            }
            const table = helpers_1.createTable(["Font", "CSS Properties"], []);
            for (const file of files) {
                const font = yield fontFinder.get(fontsFolderPath + "/" + file.base);
                table.push([
                    file.base,
                    `font-family: "${font.name}", "${file.name}"; font-weight: ${font.weight};`,
                ]);
            }
            this.$logger.info(table.toString());
        });
    }
}
exports.FontsCommand = FontsCommand;
yok_1.injector.registerCommand("fonts", FontsCommand);
