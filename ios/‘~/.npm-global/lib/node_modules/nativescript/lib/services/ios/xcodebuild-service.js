"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XcodebuildService = void 0;
const path = require("path");
const yok_1 = require("../../common/yok");
class XcodebuildService {
    constructor($exportOptionsPlistService, $xcodebuildArgsService, $xcodebuildCommandService) {
        this.$exportOptionsPlistService = $exportOptionsPlistService;
        this.$xcodebuildArgsService = $xcodebuildArgsService;
        this.$xcodebuildCommandService = $xcodebuildCommandService;
    }
    buildForDevice(platformData, projectData, buildConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this.$xcodebuildArgsService.getBuildForDeviceArgs(platformData, projectData, buildConfig);
            yield this.$xcodebuildCommandService.executeCommand(args, {
                cwd: platformData.projectRoot,
                stdio: buildConfig && buildConfig.buildOutputStdio,
            });
            const archivePath = yield this.createDevelopmentArchive(platformData, projectData, buildConfig);
            return archivePath;
        });
    }
    buildForSimulator(platformData, projectData, buildConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this.$xcodebuildArgsService.getBuildForSimulatorArgs(platformData, projectData, buildConfig);
            yield this.$xcodebuildCommandService.executeCommand(args, {
                cwd: platformData.projectRoot,
                stdio: buildConfig.buildOutputStdio,
            });
        });
    }
    buildForAppStore(platformData, projectData, buildConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this.$xcodebuildArgsService.getBuildForDeviceArgs(platformData, projectData, buildConfig);
            yield this.$xcodebuildCommandService.executeCommand(args, {
                cwd: platformData.projectRoot,
                stdio: buildConfig && buildConfig.buildOutputStdio,
            });
            const archivePath = yield this.createDistributionArchive(platformData, projectData, buildConfig);
            return archivePath;
        });
    }
    createDevelopmentArchive(platformData, projectData, buildConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const archivePath = path.join(platformData.getBuildOutputPath(buildConfig), projectData.projectName + ".xcarchive");
            const output = yield this.$exportOptionsPlistService.createDevelopmentExportOptionsPlist(archivePath, projectData, buildConfig);
            const args = [
                "-exportArchive",
                "-archivePath",
                archivePath,
                "-exportPath",
                output.exportFileDir,
                "-exportOptionsPlist",
                output.exportOptionsPlistFilePath,
            ];
            yield this.$xcodebuildCommandService.executeCommand(args, {
                cwd: platformData.projectRoot,
                stdio: buildConfig.buildOutputStdio,
            });
            return output.exportFilePath;
        });
    }
    createDistributionArchive(platformData, projectData, buildConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const archivePath = path.join(platformData.getBuildOutputPath(buildConfig), projectData.projectName + ".xcarchive");
            const output = yield this.$exportOptionsPlistService.createDistributionExportOptionsPlist(archivePath, projectData, buildConfig);
            const args = [
                "-exportArchive",
                "-archivePath",
                archivePath,
                "-exportPath",
                output.exportFileDir,
                "-exportOptionsPlist",
                output.exportOptionsPlistFilePath,
            ];
            yield this.$xcodebuildCommandService.executeCommand(args, {
                cwd: platformData.projectRoot,
            });
            return output.exportFilePath;
        });
    }
}
exports.XcodebuildService = XcodebuildService;
yok_1.injector.register("xcodebuildService", XcodebuildService);
