"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectCleanupService = void 0;
const yok_1 = require("../common/yok");
const path = require("path");
class ProjectCleanupService {
    constructor($fs, $logger, $projectHelper, $terminalSpinnerService) {
        this.$fs = $fs;
        this.$logger = $logger;
        this.$projectHelper = $projectHelper;
        this.$terminalSpinnerService = $terminalSpinnerService;
        this.spinner = this.$terminalSpinnerService.createSpinner();
    }
    clean(pathsToClean) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const pathToClean of pathsToClean) {
                yield this.cleanPath(pathToClean).catch((error) => {
                    this.$logger.trace(`Encountered error while cleaning. Error is: ${error.message}.`, error);
                });
            }
        });
    }
    cleanPath(pathToClean) {
        return __awaiter(this, void 0, void 0, function* () {
            this.spinner.clear();
            if (!pathToClean || pathToClean.trim().length === 0) {
                this.$logger.trace("cleanPath called with no pathToClean.");
                return;
            }
            const filePath = path.resolve(this.$projectHelper.projectDir, pathToClean);
            const displayPath = `${path.relative(this.$projectHelper.projectDir, filePath)}`.yellow;
            this.$logger.trace(`Trying to clean '${filePath}'`);
            if (this.$fs.exists(filePath)) {
                const stat = this.$fs.getFsStats(filePath);
                if (stat.isDirectory()) {
                    this.$logger.trace(`Path '${filePath}' is a directory, deleting.`);
                    this.$fs.deleteDirectorySafe(filePath);
                    this.spinner.succeed(`Cleaned directory ${displayPath}`);
                }
                else {
                    this.$logger.trace(`Path '${filePath}' is a file, deleting.`);
                    this.$fs.deleteFile(filePath);
                    this.spinner.succeed(`Cleaned file ${displayPath}`);
                }
                return;
            }
            this.$logger.trace(`Path '${filePath}' not found, skipping.`);
        });
    }
}
exports.ProjectCleanupService = ProjectCleanupService;
yok_1.injector.register("projectCleanupService", ProjectCleanupService);
