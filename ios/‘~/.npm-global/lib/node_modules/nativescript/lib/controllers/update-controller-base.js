"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateControllerBase = void 0;
const path = require("path");
const semver = require("semver");
const _ = require("lodash");
class UpdateControllerBase {
    constructor($fs, $platformCommandHelper, $platformsDataService, $packageInstallationManager, $packageManager, $pacoteService) {
        this.$fs = $fs;
        this.$platformCommandHelper = $platformCommandHelper;
        this.$platformsDataService = $platformsDataService;
        this.$packageInstallationManager = $packageInstallationManager;
        this.$packageManager = $packageManager;
        this.$pacoteService = $pacoteService;
        this.getPackageManifest = _.memoize(this._getPackageManifest, (...args) => {
            return args.join("@");
        });
    }
    restoreBackup(folders, backupDir, projectDir) {
        for (const folder of folders) {
            this.$fs.deleteDirectory(path.join(projectDir, folder));
            const fileName = folder.replace(path.sep, "_");
            const folderToCopy = path.join(backupDir, fileName);
            if (this.$fs.exists(folderToCopy)) {
                this.$fs.copyFile(folderToCopy, path.resolve(projectDir, folder));
            }
        }
    }
    backup(folders, backupDir, projectDir) {
        this.$fs.deleteDirectory(backupDir);
        this.$fs.createDirectory(backupDir);
        for (const folder of folders) {
            const fileName = folder.replace(path.sep, "_");
            const folderToCopy = path.join(projectDir, folder);
            if (this.$fs.exists(folderToCopy)) {
                this.$fs.copyFile(folderToCopy, path.resolve(backupDir, fileName));
            }
        }
    }
    hasDependency(dependency, projectData) {
        const devDependencies = Object.keys(projectData.devDependencies);
        const dependencies = Object.keys(projectData.dependencies);
        return [...devDependencies, ...dependencies].some((packageName) => {
            return packageName === dependency.packageName;
        });
    }
    hasRuntimeDependency({ platform, projectData, }) {
        const lowercasePlatform = platform.toLowerCase();
        const currentPlatformVersion = this.$platformCommandHelper.getCurrentPlatformVersion(lowercasePlatform, projectData);
        return !!currentPlatformVersion;
    }
    getMaxRuntimeVersion({ platform, projectData, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const lowercasePlatform = platform.toLowerCase();
            const currentPlatformVersion = this.$platformCommandHelper.getCurrentPlatformVersion(lowercasePlatform, projectData);
            const platformData = this.$platformsDataService.getPlatformData(lowercasePlatform, projectData);
            if (currentPlatformVersion) {
                return ((yield this.$packageInstallationManager.getMaxSatisfyingVersionSafe(platformData.frameworkPackageName, currentPlatformVersion)) || currentPlatformVersion);
            }
        });
    }
    _getPackageManifest(templateName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageVersion = semver.valid(version) ||
                (yield this.$packageManager.getTagVersion(templateName, version));
            if (packageVersion && semver.valid(packageVersion)) {
                return yield this.$pacoteService.manifest(`${templateName}@${packageVersion}`, { fullMetadata: true });
            }
            else {
                throw new Error(`Failed to get information for package: ${templateName}@${version}`);
            }
        });
    }
}
exports.UpdateControllerBase = UpdateControllerBase;
